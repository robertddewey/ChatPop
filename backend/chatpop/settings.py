"""
Django settings for chatpop project.

Generated by 'django-admin startproject' using Django 5.0.14.

For more information on this file, see
https://docs.djangoproject.com/en/5.0/topics/settings/

For the full list of settings and their values, see
https://docs.djangoproject.com/en/5.0/ref/settings/
"""

from pathlib import Path
import os
from dotenv import load_dotenv

# Load environment variables
load_dotenv()

# Build paths inside the project like this: BASE_DIR / 'subdir'.
BASE_DIR = Path(__file__).resolve().parent.parent


# Quick-start development settings - unsuitable for production
# See https://docs.djangoproject.com/en/5.0/howto/deployment/checklist/

# SECURITY WARNING: keep the secret key used in production secret!
SECRET_KEY = os.getenv("DJANGO_SECRET_KEY", "django-insecure-z2vf5na(z&i^73$f3=^d89@q01fkz1dh2(e_&wp9xvwnwz%&du")

# SECURITY WARNING: don't run with debug turned on in production!
DEBUG = os.getenv("DEBUG", "True") == "True"

ALLOWED_HOSTS = os.getenv("ALLOWED_HOSTS", "localhost,127.0.0.1,10.0.0.135,testserver").split(",")


# Application definition

INSTALLED_APPS = [
    "daphne",
    "django.contrib.admin",
    "django.contrib.auth",
    "django.contrib.contenttypes",
    "django.contrib.sessions",
    "django.contrib.messages",
    "django.contrib.staticfiles",
    # Third-party apps
    "rest_framework",
    "rest_framework.authtoken",
    "drf_spectacular",
    "corsheaders",
    "channels",
    "constance",
    "constance.backends.database",
    "django_extensions",
    # Local apps
    "accounts",
    "chats",
    "photo_analysis",
]

MIDDLEWARE = [
    "django.middleware.security.SecurityMiddleware",
    "django.contrib.sessions.middleware.SessionMiddleware",
    "corsheaders.middleware.CorsMiddleware",
    "django.middleware.common.CommonMiddleware",
    "django.middleware.csrf.CsrfViewMiddleware",
    "django.contrib.auth.middleware.AuthenticationMiddleware",
    "django.contrib.messages.middleware.MessageMiddleware",
    "django.middleware.clickjacking.XFrameOptionsMiddleware",
]

ROOT_URLCONF = "chatpop.urls"

TEMPLATES = [
    {
        "BACKEND": "django.template.backends.django.DjangoTemplates",
        "DIRS": [BASE_DIR / "templates"],
        "APP_DIRS": True,
        "OPTIONS": {
            "context_processors": [
                "django.template.context_processors.debug",
                "django.template.context_processors.request",
                "django.contrib.auth.context_processors.auth",
                "django.contrib.messages.context_processors.messages",
            ],
        },
    },
]

WSGI_APPLICATION = "chatpop.wsgi.application"
ASGI_APPLICATION = "chatpop.asgi.application"


# Database
# https://docs.djangoproject.com/en/5.0/ref/settings/#databases

DATABASES = {
    "default": {
        "ENGINE": "django.db.backends.postgresql",
        "NAME": os.getenv("POSTGRES_DB", "chatpop"),
        "USER": os.getenv("POSTGRES_USER", "chatpop_user"),
        "PASSWORD": os.getenv("POSTGRES_PASSWORD", "chatpop_pass"),
        "HOST": os.getenv("POSTGRES_HOST", "localhost"),
        "PORT": os.getenv("POSTGRES_PORT", "5432"),
    }
}


# Password validation
# https://docs.djangoproject.com/en/5.0/ref/settings/#auth-password-validators

AUTH_PASSWORD_VALIDATORS = [
    {
        "NAME": "django.contrib.auth.password_validation.UserAttributeSimilarityValidator",
    },
    {
        "NAME": "django.contrib.auth.password_validation.MinimumLengthValidator",
    },
    {
        "NAME": "django.contrib.auth.password_validation.CommonPasswordValidator",
    },
    {
        "NAME": "django.contrib.auth.password_validation.NumericPasswordValidator",
    },
]


# Internationalization
# https://docs.djangoproject.com/en/5.0/topics/i18n/

LANGUAGE_CODE = "en-us"

TIME_ZONE = "UTC"

USE_I18N = True

USE_TZ = True


# Static files (CSS, JavaScript, Images)
# https://docs.djangoproject.com/en/5.0/howto/static-files/

STATIC_URL = "static/"
STATIC_ROOT = BASE_DIR / "staticfiles"
STATICFILES_DIRS = [
    BASE_DIR / "static",
]

# Default primary key field type
# https://docs.djangoproject.com/en/5.0/ref/settings/#default-auto-field

DEFAULT_AUTO_FIELD = "django.db.models.BigAutoField"

# Channels
CHANNEL_LAYERS = {
    "default": {
        "BACKEND": "channels_redis.core.RedisChannelLayer",
        "CONFIG": {
            "hosts": [(os.getenv("REDIS_HOST", "localhost"), int(os.getenv("REDIS_PORT", "6379")))],
        },
    },
}

# CORS Settings
CORS_ALLOWED_ORIGINS = os.getenv(
    "CORS_ALLOWED_ORIGINS",
    "http://localhost:4000,http://127.0.0.1:4000,http://10.0.0.135:4000"
).split(",")

CORS_ALLOW_CREDENTIALS = True

# REST Framework
REST_FRAMEWORK = {
    "DEFAULT_RENDERER_CLASSES": [
        "rest_framework.renderers.JSONRenderer",
        "rest_framework.renderers.BrowsableAPIRenderer",
    ],
    "DEFAULT_PARSER_CLASSES": [
        "rest_framework.parsers.JSONParser",
    ],
    "DEFAULT_AUTHENTICATION_CLASSES": [
        "rest_framework.authentication.TokenAuthentication",
        "rest_framework.authentication.SessionAuthentication",
    ],
    "DEFAULT_PAGINATION_CLASS": "rest_framework.pagination.PageNumberPagination",
    "PAGE_SIZE": 50,
    "DEFAULT_SCHEMA_CLASS": "drf_spectacular.openapi.AutoSchema",
}

# API Documentation
SPECTACULAR_SETTINGS = {
    "TITLE": "ChatPop API",
    "DESCRIPTION": "REST API for ChatPop - Create and join chat rooms with monetization features",
    "VERSION": "1.0.0",
    "SERVE_INCLUDE_SCHEMA": False,
    "COMPONENT_SPLIT_REQUEST": True,
    "SCHEMA_PATH_PREFIX": "/api/",
}

# Stripe
STRIPE_SECRET_KEY = os.getenv("STRIPE_SECRET_KEY", "")
STRIPE_PUBLISHABLE_KEY = os.getenv("STRIPE_PUBLISHABLE_KEY", "")

# Redis
REDIS_HOST = os.getenv("REDIS_HOST", "localhost")
REDIS_PORT = int(os.getenv("REDIS_PORT", "6379"))

# Django Cache (for message caching)
CACHES = {
    "default": {
        "BACKEND": "django_redis.cache.RedisCache",
        "LOCATION": f"redis://{REDIS_HOST}:{REDIS_PORT}/1",
        "OPTIONS": {
            "CLIENT_CLASS": "django_redis.client.DefaultClient",
            "CONNECTION_POOL_KWARGS": {"max_connections": 50},
        }
    }
}

# Message Cache Settings
MESSAGE_CACHE_MAX_COUNT = int(os.getenv("MESSAGE_CACHE_MAX_COUNT", "500"))  # Max messages per chat in Redis
MESSAGE_CACHE_TTL_HOURS = int(os.getenv("MESSAGE_CACHE_TTL_HOURS", "24"))  # Auto-expire after 24 hours

# Constance - Dynamic Settings (editable in /admin/constance/config/)
CONSTANCE_BACKEND = 'constance.backends.database.DatabaseBackend'
CONSTANCE_CONFIG = {
    # Message History Settings
    'MESSAGE_HISTORY_MAX_DAYS': (
        7,
        'Maximum days users can scroll back in chat history',
        int
    ),
    'MESSAGE_HISTORY_MAX_COUNT': (
        500,
        'Maximum number of messages users can load total (includes initial load + pagination)',
        int
    ),
    'MESSAGE_LIST_DEFAULT_LIMIT': (
        50,
        'Default number of messages to return per request (can be overridden with ?limit= up to MESSAGE_HISTORY_MAX_COUNT)',
        int
    ),

    # Redis Message Cache Settings (enable when scaling past 1000+ chats)
    'REDIS_CACHE_ENABLED': (
        False,
        'Enable Redis caching for messages (read + write). Recommended for 1000+ chats. 5-10x faster page loads.',
        bool
    ),
    'REDIS_CACHE_MAX_COUNT': (
        500,
        'Maximum messages cached per chat in Redis. Recommended: 100-200 for memory efficiency.',
        int
    ),
    'REDIS_CACHE_TTL_HOURS': (
        24,
        'Hours before cached messages expire from Redis (auto-cleanup for inactive chats)',
        int
    ),

    # Monitoring Settings (developer tools)
    'ENABLE_MONITORING': (
        False,
        'Enable real-time monitoring of cache/database operations. Tracks performance metrics with adaptive sampling. Access via: ./venv/bin/python manage.py monitor_cache',
        bool
    ),

    # Rate Limiting Settings
    'MAX_ANONYMOUS_USERNAMES_PER_IP_PER_CHAT': (
        3,
        'Maximum number of anonymous usernames allowed per IP address per chat room',
        int
    ),
    'MAX_USERNAME_GENERATION_ATTEMPTS_GLOBAL': (
        10,
        'Maximum number of NEW username generations per fingerprint per hour (global, across all chats). After limit is reached, users can still rotate through previously generated usernames.',
        int
    ),
    'MAX_USERNAME_GENERATION_ATTEMPTS_PER_CHAT': (
        20,
        'Maximum number of NEW username generations per fingerprint per chat per hour. Rotation through previously generated usernames does not count against this limit.',
        int
    ),

    # Username Reservation TTL Settings
    'USERNAME_RESERVATION_TTL_MINUTES': (
        60,
        'How long generated usernames are reserved in Redis (minutes). Gives users time to complete registration/join chat. Used for both anonymous and registered user flows.',
        int
    ),
    'USERNAME_VALIDATION_TTL_MINUTES': (
        10,
        'How long custom usernames are reserved after real-time validation (minutes). Prevents race conditions during form submission where two users try to register the same username.',
        int
    ),

    # User Blocking/Muting Settings
    'USER_BLOCK_CACHE_TTL_HOURS': (
        0,
        'Hours before muted user list expires from Redis (0 = never expire, recommended). Set to 168 (7 days) to auto-cleanup inactive users.',
        int
    ),

    # Photo Analysis Settings
    'PHOTO_ANALYSIS_PROMPT': (
        '''You are a chat room title generator.
Based on a photo or short description, generate 10 concise chat room title ideas.

Your goals:

Capture the core idea or vibe of the scene or topic.

Keep titles short (1â€“4 words).

Favor general, reusable topics over specific one-offs.

Avoid filler words (like "the", "a", "about", "of").

Always include a single-word version if the subject is a well-known brand, object, or universal concept (e.g., Lego, Cat, Coffee, iPhone, Ocean).

Use a mix of literal (e.g., "Gray Cat", "Coffee Beans") and conceptual (e.g., "Morning Vibes", "Chill Space") titles.

Format Rules:
- "name" field: Title Case (capitalize first letter of each word, e.g., "Curious Cat", "Coffee Time")
- "key" field: lowercase with dashes instead of spaces (e.g., "curious-cat", "coffee-time")
- "description" field: Short phrase describing the chat topic


Example:
Description: "A gray long-haired cat sitting on a marble table by a window."

Expected output (10 suggestions):

1. Cat / cat
2. Gray Cat / gray-cat
3. Curious Cat / curious-cat
4. Window Cat / window-cat
5. Morning Light / morning-light
6. Cat Life / cat-life
7. Chill Cat / chill-cat
8. Feline Friends / feline-friends
9. Home Vibes / home-vibes
10. Cozy Space / cozy-space

You must respond in json format with this exact structure:
{
"suggestions": [
{
"name": "Curious Cat",
"key": "curious-cat",
"description": "Chat about curious cats"
},
{
"name": "Gray Cat",
"key": "gray-cat",
"description": "Discuss gray cats and feline friends"
},
...
]
}

Make the topics diverse (not all similar), engaging, and directly related to what's visible in the photo. Be creative!''',
        'OpenAI Vision API prompt for generating chat suggestions from photos. Edit to tune the quality/style of suggestions. (TIP: Drag the bottom-right corner of the textarea to manually resize for easier editing)',
        str
    ),
    'PHOTO_ANALYSIS_OPENAI_MODEL': (
        'gpt-4o-mini',
        'OpenAI model to use for photo analysis (gpt-4o, gpt-4o-mini)',
        str
    ),
    'PHOTO_ANALYSIS_RATE_LIMIT_AUTHENTICATED': (
        20,
        'Maximum photo uploads per hour for authenticated users',
        int
    ),
    'PHOTO_ANALYSIS_RATE_LIMIT_ANONYMOUS': (
        5,
        'Maximum photo uploads per hour for anonymous users (tracked by fingerprint + IP)',
        int
    ),
    'PHOTO_ANALYSIS_ENABLE_RATE_LIMITING': (
        True,
        'Enable rate limiting for photo analysis uploads',
        bool
    ),
    'PHOTO_ANALYSIS_MAX_FILE_SIZE_MB': (
        10,
        'Maximum file size for photo uploads (in megabytes)',
        int
    ),
    'PHOTO_ANALYSIS_IMAGE_TTL_HOURS': (
        168,
        'Hours before uploaded images are auto-deleted (168 = 7 days, 0 = never delete)',
        int
    ),
    'PHOTO_ANALYSIS_USE_S3': (
        True,
        'Store uploaded photos in S3 (if configured). If False or S3 not configured, uses local storage.',
        bool
    ),
    'PHOTO_ANALYSIS_MAX_MEGAPIXELS': (
        2.0,
        'Maximum megapixels for uploaded images before auto-resize (reduces OpenAI token usage). 2.0 MP = ~1414x1414 pixels. Images exceeding this limit are automatically resized while preserving aspect ratio.',
        float
    ),
    'PHOTO_ANALYSIS_DETAIL_MODE': (
        'low',
        'OpenAI Vision API detail mode: "low" (fixed ~85 tokens, faster, cheaper) or "high" (tokens scale with image size, higher quality). WARNING: "high" mode currently uses ~8x more tokens than expected for unknown reasons.',
        str
    ),
    'PHOTO_ANALYSIS_TEMPERATURE': (
        0.7,
        'Temperature for chat suggestion generation (0.0-2.0). Higher = more creative/random, Lower = more deterministic. Default 0.7 for diverse chat name suggestions.',
        float
    ),

    # Photo Caption Generation Settings (for embeddings/search)
    'PHOTO_ANALYSIS_ENABLE_CAPTIONS': (
        True,
        'Enable automatic caption generation for uploaded photos. Captions are used for embedding-based image search and retrieval.',
        bool
    ),
    'PHOTO_ANALYSIS_CAPTION_PROMPT': (
        '''You are an expert visual captioner for a multimodal search system.
Your goal is to produce one or two compact, factual sentences that capture the full meaning of the image for use in a text embedding model.

The first sentence should describe what is visually present.
The second, if helpful, should add semantic or contextual meaning (e.g., what it represents, its purpose, or its genre).

Include any visible text, titles, brand names, or labels.
Avoid speculation, humor, or opinions. Do not include camera details.

Return a JSON object with this exact structure:
{
  "title": "A short, descriptive title (2-4 words)",
  "category": "General category of the image (e.g., beverage, food, animal, memorial, product)",
  "visible_text": "Any visible text, labels, or brand names in the image",
  "caption": "One or two concise sentences optimized for semantic embeddings"
}

Example:
For an image of a Budweiser beer bottle:
{
  "title": "Budweiser Beer Bottle",
  "category": "beer bottle",
  "visible_text": "Budweiser, King of Beers",
  "caption": "Budweiser beer bottle labeled 'King of Beers' with red and white logo on a wooden table. A classic American lager brand."
}''',
        'Prompt for generating semantic captions from photos. Captions are converted to embeddings for similarity search. Edit to tune caption quality/style.',
        str
    ),
    'PHOTO_ANALYSIS_CAPTION_MODEL': (
        'gpt-4o-mini',
        'OpenAI model for caption generation (gpt-4o-mini, gpt-4o). Separate from suggestion model for independent tuning.',
        str
    ),
    'PHOTO_ANALYSIS_CAPTION_TEMPERATURE': (
        0.2,
        'Temperature for caption generation (0.0-2.0). Lower = more factual/deterministic (recommended for embeddings). Default 0.2.',
        float
    ),
}

# Custom User Model
AUTH_USER_MODEL = "accounts.User"

# ChatPop Settings
# Enable/disable anonymous user fingerprinting for username persistence
# This can be toggled from Django admin
ANONYMOUS_USER_FINGERPRINT = os.getenv("ANONYMOUS_USER_FINGERPRINT", "True") == "True"

# Monitoring Settings
# Enable real-time monitoring of cache and database operations
# Disabled by default (zero overhead). Enable with: ENABLE_MONITORING=True
ENABLE_MONITORING = os.getenv("ENABLE_MONITORING", "False") == "True"

# OpenAI Settings
OPENAI_API_KEY = os.getenv("OPENAI_API_KEY", "")

# Media Storage Settings
# AWS S3 Configuration (optional - uses local storage if not configured)
AWS_ACCESS_KEY_ID = os.getenv("AWS_ACCESS_KEY_ID", "")
AWS_SECRET_ACCESS_KEY = os.getenv("AWS_SECRET_ACCESS_KEY", "")
AWS_STORAGE_BUCKET_NAME = os.getenv("AWS_STORAGE_BUCKET_NAME", "")
AWS_S3_REGION_NAME = os.getenv("AWS_S3_REGION_NAME", "us-east-1")
AWS_S3_CUSTOM_DOMAIN = os.getenv("AWS_S3_CUSTOM_DOMAIN", "")

# Determine storage backend based on AWS configuration
if AWS_ACCESS_KEY_ID and AWS_SECRET_ACCESS_KEY and AWS_STORAGE_BUCKET_NAME:
    # Use S3 storage when AWS credentials are configured
    DEFAULT_FILE_STORAGE = "storages.backends.s3boto3.S3Boto3Storage"
    AWS_S3_FILE_OVERWRITE = False
    AWS_DEFAULT_ACL = "private"  # Files are private by default
    AWS_QUERYSTRING_AUTH = False  # Don't add query string auth (we use Django proxy)
else:
    # Use local filesystem storage when AWS credentials are not configured
    DEFAULT_FILE_STORAGE = "django.core.files.storage.FileSystemStorage"
    MEDIA_ROOT = BASE_DIR / "media"
    MEDIA_URL = "/media/"
